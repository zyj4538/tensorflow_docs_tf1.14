<!DOCTYPE html>
<html devsite>
<head>
  <title>tensorflow::ops::QuantizedReshape Class Reference</title>
  <meta name="project_path" value="/_project.yaml" />
  <meta name="book_path" value="/versions/r1.14/api_docs/_book.yaml" />
  <meta name="hide_page_heading" value="true" />
</head>
<body>
  <div id="top"><!-- do not remove this div --></div>
  <h1>tensorflow::<wbr/>ops::<wbr/>QuantizedReshape</h1>
  <code>#include &lt;array_ops.h&gt;</code>
  <p>Packs a list of <code>N</code> rank-<code>R</code> tensors into one rank-<code>(R+1)</code> tensor. </p>
  <h2>Summary</h2>
  <p>Packs the <code>N</code> tensors in <code>values</code> into a tensor with rank one higher than each tensor in <code>values</code>, by packing them along the <code>axis</code> dimension. Given a list of tensors of shape <code>(A, B, C)</code>;</p>
  <p>if <code>axis == 0</code> then the <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>. if <code>axis == 1</code> then the <code>output</code> tensor will have the shape <code>(A, N, B, C)</code>. Etc.</p>
  <p>For example:</p>
  <p>
    <h1>'x' is [1, 4]</h1>
  </p>
  <p>
    <h1>'y' is [2, 5]</h1>
  </p>
  <p>
    <h1>'z' is [3, 6]</h1>
  </p>
  <p>pack([x, y, z]) => [[1, 4], [2, 5], [3, 6]] # Pack along first dim. pack([x, y, z], axis=1) => [[1, 2, 3], [4, 5, 6]] <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    This is the opposite of `unpack`.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * values: Must be of same shape and type.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Optional attributes (see `Attrs`):
    * axis: Dimension along which to pack.  Negative values wrap around, so the
    valid range is `[-(R+1), R+1)`.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: The packed tensor. */
class Stack {
 public:
  /// Optional attribute setters for Stack
  struct Attrs {
    /** Dimension along which to pack.  Negative values wrap around, so the
        valid range is `[-(R+1), R+1)`.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to 0 */
    TF_MUST_USE_RESULT Attrs Axis(int64 x) {
      Attrs ret = *this;
      ret.axis_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    int64 axis_ = 0;
  };
  Stack(const ::tensorflow::Scope& scope, ::tensorflow::InputList values);
  Stack(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input-list.html#classtensorflow_1_1_input_list">tensorflow::InputList</a> values, const
      Stack::Attrs& attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint">  static Attrs Axis(int64 x) {
    return Attrs().Axis(x);
  }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Pads a tensor with zeros.</pre>
  </p>
  <p>
    <pre class="prettyprint">    This operation pads a `input` with zeros according to the `paddings` you
    specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the
    rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
    how many zeros to add before the contents of `input` in that dimension, and
    `paddings[D, 1]` indicates how many zeros to add after the contents of `input`
    in that dimension.</pre>
  </p>
  <p>
    <pre class="prettyprint">    The padded size of each dimension D of the output is:</pre>
  </p>
  <p>
    <pre class="prettyprint">    `paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`</pre>
  </p>
  <p>
    <pre class="prettyprint">    For example:</pre>
  </p>
  <p>
    <pre class="prettyprint" />
    <h1>'t' is [[1, 1], [2, 2]]</h1>
  </p>
  <p>
    <h1>'paddings' is [[1, 1], [2, 2]]</h1>
  </p>
  <p>
    <h1>rank of 't' is 2</h1>
  </p>
  <p>pad(t, paddings) ==> [[0, 0, 0, 0, 0, 0] [0, 0, 1, 1, 0, 0] [0, 0, 2, 2, 0, 0] [0, 0, 0, 0, 0, 0]] <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: The output tensor. */
class Pad {
 public:
  Pad(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input,
    <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> paddings);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Pads a tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    This operation pads `input` according to the `paddings` and `constant_values`
    you specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is
    the rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
    how many padding values to add before the contents of `input` in that dimension,
    and `paddings[D, 1]` indicates how many padding values to add after the contents
    of `input` in that dimension. `constant_values` is a scalar tensor of the same
    type as `input` that indicates the value to use for padding `input`.</pre>
  </p>
  <p>
    <pre class="prettyprint">    The padded size of each dimension D of the output is:</pre>
  </p>
  <p>
    <pre class="prettyprint">    `paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`</pre>
  </p>
  <p>
    <pre class="prettyprint">    For example:</pre>
  </p>
  <p>
    <pre class="prettyprint" />
    <h1>'t' is [[1, 1], [2, 2]]</h1>
  </p>
  <p>
    <h1>'paddings' is [[1, 1], [2, 2]]</h1>
  </p>
  <p>
    <h1>'constant_values' is 0</h1>
  </p>
  <p>
    <h1>rank of 't' is 2</h1>
  </p>
  <p>pad(t, paddings) ==> [[0, 0, 0, 0, 0, 0] [0, 0, 1, 1, 0, 0] [0, 0, 2, 2, 0, 0] [0, 0, 0, 0, 0, 0]] <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: The output tensor. */
class PadV2 {
 public:
  PadV2(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input,
      <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> paddings, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> constant_values);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Concatenates a list of `N` tensors along the first dimension.</pre>
  </p>
  <p>
    <pre class="prettyprint">    The input tensors are all required to have size 1 in the first dimension.</pre>
  </p>
  <p>
    <pre class="prettyprint">    For example:</pre>
  </p>
  <p>
    <pre class="prettyprint" />
    <h1>'x' is [[1, 4]]</h1>
  </p>
  <p>
    <h1>'y' is [[2, 5]]</h1>
  </p>
  <p>
    <h1>'z' is [[3, 6]]</h1>
  </p>
  <p>parallel_concat([x, y, z]) => [[1, 4], [2, 5], [3, 6]] # Pack along first dim. <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    The difference between concat and parallel_concat is that concat requires all
    of the inputs be computed before the operation will begin but doesn't require
    that the input shapes be known during graph construction.  Parallel concat
    will copy pieces of the input into the output as they become available, in
    some situations this can provide a performance benefit.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * values: Tensors to be concatenated. <a href="/versions/r1.14/api_docs/cc/class/tensorflow/ops/all.html#classtensorflow_1_1ops_1_1_all">All</a> must have size 1 in the first dimension
    and same shape.
    * shape: the final shape of the result; should be equal to the shapes of any input
    but with the number of input values in the first dimension.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: The concatenated tensor. */
class ParallelConcat {
 public:
  ParallelConcat(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input-list.html#classtensorflow_1_1_input_list">tensorflow::InputList</a>
               values, PartialTensorShape shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** A placeholder op for a value that will be fed into the computation.</pre>
  </p>
  <p>
    <pre class="prettyprint">    N.B. This operation will fail with an error if it is executed. It is
    intended as a way to represent a value that will always be fed, and to
    provide attrs that enable the fed value to be checked at runtime.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * dtype: The type of elements in the tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Optional attributes (see `Attrs`):
    * shape: (Optional) The shape of the tensor. If the shape has 0 dimensions, the
    shape is unconstrained.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: A placeholder tensor that must be replaced using the feed mechanism. */
class Placeholder {
 public:
  /// Optional attribute setters for Placeholder
  struct Attrs {
    /** (Optional) The shape of the tensor. If the shape has 0 dimensions, the
        shape is unconstrained.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to <unknown> */
    TF_MUST_USE_RESULT Attrs Shape(PartialTensorShape x) {
      Attrs ret = *this;
      ret.shape_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    PartialTensorShape shape_ = ::tensorflow::PartialTensorShape() /* unknown */;
  };
  Placeholder(const ::tensorflow::Scope& scope, DataType dtype);
  Placeholder(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, DataType dtype, const
            Placeholder::Attrs& attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint">  static Attrs Shape(PartialTensorShape x) {
    return Attrs().Shape(x);
  }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** A placeholder op that passes through `input` when its output is not fed.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * input: The default value to produce when `output` is not fed.
    * shape: The (possibly partial) shape of the tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: A placeholder tensor that defaults to `input` if it is not fed. */
class PlaceholderWithDefault {
 public:
  PlaceholderWithDefault(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                       input, PartialTensorShape shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** An identity op that triggers an error if a gradient is requested.</pre>
  </p>
  <p>
    <pre class="prettyprint">    When executed in a graph, this op outputs its input tensor as-is.</pre>
  </p>
  <p>
    <pre class="prettyprint">    When building ops to compute gradients, the TensorFlow gradient system
    will return an error when trying to lookup the gradient of this op,
    because no gradient must ever be registered for this function.  This
    op exists to prevent subtle bugs from silently returning unimplemented
    gradients in some corner cases.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * input: any tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Optional attributes (see `Attrs`):
    * message: Will be printed in the error when anyone tries to differentiate
    this operation.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: the same input tensor. */
class PreventGradient {
 public:
  /// Optional attribute setters for PreventGradient
  struct Attrs {
    /** Will be printed in the error when anyone tries to differentiate
        this operation.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to "" */
    TF_MUST_USE_RESULT Attrs Message(StringPiece x) {
      Attrs ret = *this;
      ret.message_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    StringPiece message_ = "";
  };
  PreventGradient(const ::tensorflow::Scope& scope, ::tensorflow::Input input);
  PreventGradient(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input,
                const PreventGradient::Attrs& attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint">  static Attrs Message(StringPiece x) {
    return Attrs().Message(x);
  }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Quantizes then dequantizes a tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    This op simulates the precision loss from the quantized forward pass by:</pre>
  </p>
  <p>
    <pre class="prettyprint">    1. Quantizing the tensor to fixed point numbers, which should match the target
       quantization method when it is used in inference.
    2. Dequantizing it back to floating point numbers for the following ops, most
       likely matmul.</pre>
  </p>
  <p>
    <pre class="prettyprint">    There are different ways to quantize. This version uses only scaling, so 0.0
    maps to 0.</pre>
  </p>
  <p>
    <pre class="prettyprint">    From the specified 'num_bits' in the quantized output type, it determines
    minimum and maximum representable quantized values.</pre>
  </p>
  <p>
    <pre class="prettyprint">    e.g.</pre>
  </p>
  <p>
    <pre class="prettyprint">    *   [-128, 127] for signed, num_bits = 8, or
    *   [0, 255] for unsigned, num_bits = 8.</pre>
  </p>
  <p>
    <pre class="prettyprint">    If range_given == False, the initial input_min, input_max will be determined
    automatically as the minimum and maximum values in the input tensor, otherwise
    the specified values of input_min, input_max are used.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Note: If the input_min, input_max are specified, they do not need to equal the
    actual minimum and maximum values in the tensor. e.g. in some cases it may be
    beneficial to specify these values such that the low probability extremes of the
    input distribution are clipped.</pre>
  </p>
  <p>
    <pre class="prettyprint">    This op determines the maximum scale_factor that would map the initial
    [input_min, input_max] range to a range that lies within the representable
    quantized range.</pre>
  </p>
  <p>
    <pre class="prettyprint">    It determines the scale from one of input_min and input_max, then updates the
    other one to maximize the respresentable range.</pre>
  </p>
  <p>
    <pre class="prettyprint">    e.g.</pre>
  </p>
  <p>
    <pre class="prettyprint">    *   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,
        5.0]: it would use a scale_factor of -128 / -10.0 = 12.8 In this case, it
        would update input_max to be 127 / 12.8 = 9.921875
    *   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,
        10.0]: it would use a scale_factor of 127 / 10.0 = 12.7 In this case, it
        would update input_min to be 128.0 / 12.7 = -10.07874
    *   if the output is unsigned, input_min is forced to be 0, and only the
        specified input_max is used.</pre>
  </p>
  <p>
    <pre class="prettyprint">    After determining the scale_factor and updating the input range, it applies the
    following to each value in the 'input' tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    output = round(clamp(value, input_min, input_max) * scale_factor) / scale_factor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * input: <a href="/versions/r1.14/api_docs/cc/class/tensorflow/tensor.html#classtensorflow_1_1_tensor">Tensor</a> to quantize and then dequantize.
    * input_min: If `range_given == True`, this specifies the minimum input value that needs to
    be represented, otherwise it is determined from the min value of the `input`
    tensor.
    * input_max: If `range_given == True`, this specifies the maximum input value that needs to
    be represented, otherwise it is determined from the max value of the `input`
    tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Optional attributes (see `Attrs`):
    * signed_input: Whether the quantization is signed or unsigned. (actually this parameter should
    have been called <b>`signed_output`</b>)
    * num_bits: The bitwidth of the quantization.
    * range_given: Whether the range is given or should be determined from the `input` tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: The output tensor. */
class QuantizeAndDequantizeV2 {
 public:
  /// Optional attribute setters for QuantizeAndDequantizeV2
  struct Attrs {
    /** Whether the quantization is signed or unsigned. (actually this parameter should
        have been called <b>`signed_output`</b>)</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to true */
    TF_MUST_USE_RESULT Attrs SignedInput(bool x) {
      Attrs ret = *this;
      ret.signed_input_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /** The bitwidth of the quantization.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to 8 */
    TF_MUST_USE_RESULT Attrs NumBits(int64 x) {
      Attrs ret = *this;
      ret.num_bits_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /** Whether the range is given or should be determined from the `input` tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to false */
    TF_MUST_USE_RESULT Attrs RangeGiven(bool x) {
      Attrs ret = *this;
      ret.range_given_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    bool signed_input_ = true;
    int64 num_bits_ = 8;
    bool range_given_ = false;
  };
  QuantizeAndDequantizeV2(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                        input, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_min,
                        <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_max);
  QuantizeAndDequantizeV2(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                        input, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_min,
                        <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_max, const
                        QuantizeAndDequantizeV2::Attrs& attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint">  static Attrs SignedInput(bool x) {
    return Attrs().SignedInput(x);
  }
  static Attrs NumBits(int64 x) {
    return Attrs().NumBits(x);
  }
  static Attrs RangeGiven(bool x) {
    return Attrs().RangeGiven(x);
  }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Quantizes then dequantizes a tensor.</pre>
  </p>
  <p>
    <pre class="prettyprint">    This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a
    tensor, so its value can change during training.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output`: The output tensor. */
class QuantizeAndDequantizeV3 {
 public:
  /// Optional attribute setters for QuantizeAndDequantizeV3
  struct Attrs {
    /// Defaults to true
    TF_MUST_USE_RESULT Attrs SignedInput(bool x) {
      Attrs ret = *this;
      ret.signed_input_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /// Defaults to true
    TF_MUST_USE_RESULT Attrs RangeGiven(bool x) {
      Attrs ret = *this;
      ret.range_given_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    bool signed_input_ = true;
    bool range_given_ = true;
  };
  QuantizeAndDequantizeV3(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                        input, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_min,
                        <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_max, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                        num_bits);
  QuantizeAndDequantizeV3(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                        input, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_min,
                        <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_max, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                        num_bits, const QuantizeAndDequantizeV3::Attrs& attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre>
  </p>
  <p>
    <pre class="prettyprint">  static Attrs SignedInput(bool x) {
    return Attrs().SignedInput(x);
  }
  static Attrs RangeGiven(bool x) {
    return Attrs().RangeGiven(x);
  }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.</pre>
  </p>
  <p>
    <pre class="prettyprint">    [min_range, max_range] are scalar floats that specify the range for
    the 'input' data. The 'mode' attribute controls exactly which calculations are
    used to convert the float values to their quantized equivalents.  The
    'round_mode' attribute controls which rounding tie-breaking algorithm is used
    when rounding float values to their quantized equivalents.</pre>
  </p>
  <p>
    <pre class="prettyprint">    In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:</pre>
  </p>
  <p><pre class="prettyprint" /> out[i] = (in[i] - min_range) * range(T) / (max_range - min_range) if T == qint8, out[i] -= (range(T) + 1) / 2.0 <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    here `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`</pre>
  </p>
  <p>
    <pre class="prettyprint">    *MIN_COMBINED Mode Example*</pre>
  </p>
  <p>
    <pre class="prettyprint">    Assume the input is type float and has a possible range of [0.0, 6.0] and the
    output type is quint8 ([0, 255]). The min_range and max_range values should be
    specified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each
    value of the input by 255/6 and cast to quint8.</pre>
  </p>
  <p>
    <pre class="prettyprint">    If the output type was qint8 ([-128, 127]), the operation will additionally
    subtract each value by 128 prior to casting, so that the range of values aligns
    with the range of qint8.</pre>
  </p>
  <p>
    <pre class="prettyprint">    If the mode is 'MIN_FIRST', then this approach is used:</pre>
  </p>
  <p><pre class="prettyprint" /> num_discrete_values = 1 << (# of bits in T) range_adjust = num_discrete_values / (num_discrete_values - 1) range = (range_max - range_min) * range_adjust range_scale = num_discrete_values / range quantized = round(input * range_scale) - round(range_min * range_scale) + numeric_limits<T>::min() quantized = max(quantized, numeric_limits<T>::min()) quantized = min(quantized, numeric_limits<T>::max()) <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    The biggest difference between this and MIN_COMBINED is that the minimum range
    is rounded first, before it's subtracted from the rounded value. With
    MIN_COMBINED, a small bias is introduced where repeated iterations of quantizing
    and dequantizing will introduce a larger and larger error.</pre>
  </p>
  <p>
    <pre class="prettyprint">    *SCALED mode Example*</pre>
  </p>
  <p>
    <pre class="prettyprint">    `SCALED` mode matches the quantization approach used in
    `QuantizeAndDequantize{V2|V3}`.</pre>
  </p>
  <p>
    <pre class="prettyprint">    If the mode is `SCALED`, we do not use the full range of the output type,
    choosing to elide the lowest possible value for symmetry (e.g., output range is
    -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to
    0.</pre>
  </p>
  <p>
    <pre class="prettyprint">    We first find the range of values in our tensor. The
    range we use is always centered on 0, so we find m such that</pre>
  </p>
  <p><pre class="prettyprint" />c++ m = max(abs(input_min), abs(input_max)) <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    Our input tensor range is then `[-m, m]`.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Next, we choose our fixed-point quantization buckets, `[min_fixed, max_fixed]`.
    If T is signed, this is</pre>
  </p>
  <p><pre class="prettyprint" /> num_bits = sizeof(T) * 8 [min_fixed, max_fixed] = [-(1 << (num_bits - 1) - 1), (1 << (num_bits - 1)) - 1] <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    Otherwise, if T is unsigned, the fixed-point range is</pre>
  </p>
  <p><pre class="prettyprint" /> [min_fixed, max_fixed] = [0, (1 << num_bits) - 1] <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    From this we compute our scaling factor, s:</pre>
  </p>
  <p><pre class="prettyprint" />c++ s = (max_fixed - min_fixed) / (2 * m) <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    Now we can quantize the elements of our tensor:</pre>
  </p>
  <p><pre class="prettyprint" />c++ result = round(input * s) <pre class="prettyprint" /></p>
  <p>
    <pre class="prettyprint">    One thing to watch out for is that the operator may choose to adjust the
    requested minimum and maximum values slightly during the quantization process,
    so you should always use the output ports as the range for further calculations.
    For example, if the requested minimum and maximum values are close to equal,
    they will be separated by a small epsilon value to prevent ill-formed quantized
    buffers from being created. Otherwise, you can end up with buffers where all the
    quantized values map to the same float value, which causes problems for
    operations that have to perform further calculations on them.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * min_range: The minimum scalar value possibly produced for the input.
    * max_range: The maximum scalar value possibly produced for the input.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output` output: The quantized data produced from the float input.
    * `Output` output_min: The actual minimum scalar value used for the output.
    * `Output` output_max: The actual maximum scalar value used for the output. */
class QuantizeV2 {
 public:
  /// Optional attribute setters for QuantizeV2
  struct Attrs {
    /// Defaults to "MIN_COMBINED"
    TF_MUST_USE_RESULT Attrs Mode(StringPiece x) {
      Attrs ret = *this;
      ret.mode_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /// Defaults to "HALF_AWAY_FROM_ZERO"
    TF_MUST_USE_RESULT Attrs RoundMode(StringPiece x) {
      Attrs ret = *this;
      ret.round_mode_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    StringPiece mode_ = "MIN_COMBINED";
    StringPiece round_mode_ = "HALF_AWAY_FROM_ZERO";
  };
  QuantizeV2(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input,
           <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> min_range, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> max_range,
           DataType T);
  QuantizeV2(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input,
           <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> min_range, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> max_range,
           DataType T, const QuantizeV2::Attrs& attrs);</pre>
  </p>
  <p>
    <pre class="prettyprint">  static Attrs Mode(StringPiece x) {
    return Attrs().Mode(x);
  }
  static Attrs RoundMode(StringPiece x) {
    return Attrs().RoundMode(x);
  }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output_min;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output_max;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Concatenates quantized tensors along one dimension.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * concat_dim: 0-D.  The dimension along which to concatenate.  Must be in the
    range [0, rank(values)).
    * values: The `N` Tensors to concatenate. Their ranks and types must match,
    and their sizes must match in all dimensions except `concat_dim`.
    * input_mins: The minimum scalar values for each of the input tensors.
    * input_maxes: The maximum scalar values for each of the input tensors.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output` output: A `Tensor` with the concatenation of values stacked along the
    `concat_dim` dimension.  This tensor's shape matches that of `values` except
    in `concat_dim` where it has the sum of the sizes.
    * `Output` output_min: The float value that the minimum quantized output value represents.
    * `Output` output_max: The float value that the maximum quantized output value represents. */
class QuantizedConcat {
 public:
  QuantizedConcat(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a>
                concat_dim, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input-list.html#classtensorflow_1_1_input_list">tensorflow::InputList</a> values,
                <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input-list.html#classtensorflow_1_1_input_list">tensorflow::InputList</a> input_mins, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input-list.html#classtensorflow_1_1_input_list">tensorflow::InputList</a>
                input_maxes);</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output_min;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output_max;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Quantized Instance normalization.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Arguments:
    * scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object
    * x: A 4D input <a href="/versions/r1.14/api_docs/cc/class/tensorflow/tensor.html#classtensorflow_1_1_tensor">Tensor</a>.
    * x_min: The value represented by the lowest quantized input.
    * x_max: The value represented by the highest quantized input.</pre>
  </p>
  <p>
    <pre class="prettyprint">    Optional attributes (see `Attrs`):
    * output_range_given: If True, `given_y_min` and `given_y_min`
    and `given_y_max` are used as the output range. Otherwise,
    the implementation computes the output range.
    * given_y_min: <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">Output</a> in `y_min` if `output_range_given` is True.
    * given_y_max: <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">Output</a> in `y_max` if `output_range_given` is True.
    * variance_epsilon: A small float number to avoid dividing by 0.
    * min_separation: <a href="/versions/r1.14/api_docs/cc/class/tensorflow/ops/minimum.html#classtensorflow_1_1ops_1_1_minimum">Minimum</a> value of `y_max - y_min`</pre>
  </p>
  <p>
    <pre class="prettyprint">    Returns:
    * `Output` y: A 4D <a href="/versions/r1.14/api_docs/cc/class/tensorflow/tensor.html#classtensorflow_1_1_tensor">Tensor</a>.
    * `Output` y_min: The value represented by the lowest quantized output.
    * `Output` y_max: The value represented by the highest quantized output. */
class QuantizedInstanceNorm {
 public:
  /// Optional attribute setters for QuantizedInstanceNorm
  struct Attrs {
    /** If True, `given_y_min` and `given_y_min`
        and `given_y_max` are used as the output range. Otherwise,
        the implementation computes the output range.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to false */
    TF_MUST_USE_RESULT Attrs OutputRangeGiven(bool x) {
      Attrs ret = *this;
      ret.output_range_given_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /** <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">Output</a> in `y_min` if `output_range_given` is True.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to 0 */
    TF_MUST_USE_RESULT Attrs GivenYMin(float x) {
      Attrs ret = *this;
      ret.given_y_min_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /** <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">Output</a> in `y_max` if `output_range_given` is True.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to 0 */
    TF_MUST_USE_RESULT Attrs GivenYMax(float x) {
      Attrs ret = *this;
      ret.given_y_max_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /** A small float number to avoid dividing by 0.</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to 1e-05 */
    TF_MUST_USE_RESULT Attrs VarianceEpsilon(float x) {
      Attrs ret = *this;
      ret.variance_epsilon_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    /** <a href="/versions/r1.14/api_docs/cc/class/tensorflow/ops/minimum.html#classtensorflow_1_1ops_1_1_minimum">Minimum</a> value of `y_max - y_min`</pre>
  </p>
  <p>
    <pre class="prettyprint">        Defaults to 0.001 */
    TF_MUST_USE_RESULT Attrs MinSeparation(float x) {
      Attrs ret = *this;
      ret.min_separation_ = x;
      return ret;
    }</pre>
  </p>
  <p>
    <pre class="prettyprint">    bool output_range_given_ = false;
    float given_y_min_ = 0.0f;
    float given_y_max_ = 0.0f;
    float variance_epsilon_ = 1e-05f;
    float min_separation_ = 0.001f;
  };
  QuantizedInstanceNorm(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> x,
                      <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> x_min, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> x_max);
  QuantizedInstanceNorm(const <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a>& scope, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> x,
                      <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> x_min, <a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> x_max,
                      const QuantizedInstanceNorm::Attrs& attrs);</pre>
  </p>
  <p>
    <pre class="prettyprint">  static Attrs OutputRangeGiven(bool x) {
    return Attrs().OutputRangeGiven(x);
  }
  static Attrs GivenYMin(float x) {
    return Attrs().GivenYMin(x);
  }
  static Attrs GivenYMax(float x) {
    return Attrs().GivenYMax(x);
  }
  static Attrs VarianceEpsilon(float x) {
    return Attrs().VarianceEpsilon(x);
  }
  static Attrs MinSeparation(float x) {
    return Attrs().MinSeparation(x);
  }</pre>
  </p>
  <p>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> y;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> y_min;
  <a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> y_max;
};</pre>
  </p>
  <p>
    <pre class="prettyprint">/** Reshapes a quantized tensor as per the <a href="/versions/r1.14/api_docs/cc/class/tensorflow/ops/reshape.html#classtensorflow_1_1ops_1_1_reshape">Reshape</a> op.</pre>
  </p>
  <p>
    <pre class="prettyprint" />
  </p>
  <p>Arguments:<ul>
      <li>scope: A <a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">Scope</a> object</li>
      <li>shape: Defines the shape of the output tensor.</li>
      <li>input_min: The minimum value of the input.</li>
      <li>input_max: The maximum value of the input.</li>
    </ul></p>
  <p>Returns:<ul>
      <li><code><a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">Output</a></code> output</li>
      <li><code><a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">Output</a></code> output_min: This value is copied from input_min.</li>
      <li><code><a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">Output</a></code> output_max: This value is copied from input_max. </li>
    </ul></p>
  <table class="constructors responsive">
    <tr>
      <th colspan="2">
        <h3>Constructors and Destructors</h3>
      </th>
    </tr>
    <tr>
      <td colspan="2">
        <code><a href="#classtensorflow_1_1ops_1_1_quantized_reshape_1a1586a9fd66e72c76f752e7641f6a191f">QuantizedReshape</a>(const ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a> & scope, ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> tensor, ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> shape, ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_min, ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_max)</code>
        <br />
      </td>
    </tr>
  </table>
  <table class="properties responsive">
    <tr>
      <th colspan="2">
        <h3>Public attributes</h3>
      </th>
    </tr>
    <tr>
      <td>
        <code><a href="#classtensorflow_1_1ops_1_1_quantized_reshape_1a779f1990c51173afd23d970d4387a6ff">operation</a></code>
      </td>
      <td>
        <div>
          <code><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a></code>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <code><a href="#classtensorflow_1_1ops_1_1_quantized_reshape_1a83f4f02b01effc15393ce0cd24cfee85">output</a></code>
      </td>
      <td>
        <div>
          <code>::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a></code>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <code><a href="#classtensorflow_1_1ops_1_1_quantized_reshape_1ac5caddbc5b5bc5a524ff95ff71db1842">output_max</a></code>
      </td>
      <td>
        <div>
          <code>::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a></code>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <code><a href="#classtensorflow_1_1ops_1_1_quantized_reshape_1aa5ba6ab97eb0e9e29852f08f1c63e136">output_min</a></code>
      </td>
      <td>
        <div>
          <code>::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a></code>
        </div>
      </td>
    </tr>
  </table>
  <h2>Public attributes</h2>
  <div id="classtensorflow_1_1ops_1_1_quantized_reshape_1a779f1990c51173afd23d970d4387a6ff">
    <h3>operation</h3>
    <pre class="prettyprint"><a href="/versions/r1.14/api_docs/cc/class/tensorflow/operation.html#classtensorflow_1_1_operation">Operation</a> operation</pre>
    <div />
  </div>
  <div id="classtensorflow_1_1ops_1_1_quantized_reshape_1a83f4f02b01effc15393ce0cd24cfee85">
    <h3>output</h3>
    <pre class="prettyprint">::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output</pre>
    <div />
  </div>
  <div id="classtensorflow_1_1ops_1_1_quantized_reshape_1ac5caddbc5b5bc5a524ff95ff71db1842">
    <h3>output_max</h3>
    <pre class="prettyprint">::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output_max</pre>
    <div />
  </div>
  <div id="classtensorflow_1_1ops_1_1_quantized_reshape_1aa5ba6ab97eb0e9e29852f08f1c63e136">
    <h3>output_min</h3>
    <pre class="prettyprint">::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/output.html#classtensorflow_1_1_output">tensorflow::Output</a> output_min</pre>
    <div />
  </div>
  <h2>Public functions</h2>
  <div id="classtensorflow_1_1ops_1_1_quantized_reshape_1a1586a9fd66e72c76f752e7641f6a191f">
    <h3>QuantizedReshape</h3>
    <pre class="prettyprint"> QuantizedReshape(
  const ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a> & scope,
  ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> tensor,
  ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> shape,
  ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_min,
  ::<a href="/versions/r1.14/api_docs/cc/class/tensorflow/input.html#classtensorflow_1_1_input">tensorflow::Input</a> input_max
)</pre>
    <div />
  </div>
</body>
</html>
